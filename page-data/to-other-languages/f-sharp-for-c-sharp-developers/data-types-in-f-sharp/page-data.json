{"componentChunkName":"component---src-templates-docs-js","path":"/to-other-languages/f-sharp-for-c-sharp-developers/data-types-in-f-sharp","result":{"data":{"site":{"siteMetadata":{"title":".NET Thailand","docsLocation":"https://github.com/dotnetthailand/dotnetthailand.github.io","docsRepo":"dotnetthailand/dotnetthailand.github.io","docsLocationType":"github","editable":true,"contentRootPath":"content","siteUrl":"https://www.dotnetthailand.com"}},"mdx":{"fields":{"id":"94492c9e-bd82-5b07-adb2-5611c2c9a230","title":"Data Types in F#","slug":"/to-other-languages/f-sharp-for-c-sharp-developers/data-types-in-f-sharp"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Data Types in F#\",\n  \"showMetadata\": true,\n  \"editable\": true,\n  \"showToc\": true,\n  \"order\": 3\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In chapter 1, I have shown some mapping between C# data types and F# data types. In this chapter, I will introduce F#'s exotic data types and values. Some types may look scary or hurt your head for the very first time usages, but they'll be a wonderful gift once you can grasp their concept. \\uD83D\\uDE06\"), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Type Alias\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This is what I really wish to have in C# language but I always wonder why it's never happened.. In C# we can do type alias on file scope basis. If you ever write a thing like this..\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"using System;\\nusing PersonAddressDictionary = System.Collections.Generic.Dictionary<string,MyProgram.Address>;\\n\\nnamespace MyProgram {\\n    public static class Program {\\n        PersonAddressDictionary personDict = new();  // C# 9 syntax\\n    }\\n}\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Problem is you need that long line on every C# file that uses the same type.  In F#, it has type alias \\uD83D\\uDC96!\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-fsharp\"\n  }, \"open System\\n\\nmodule MyProgram\\n\\ntype PersonAddressDictionary = System.Collections.Generic.Dictionary<string,Address>\\n\\nlet personDict = PersonAddressDictionary()\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PersonAddressDictionary\"), \" type can be reused in other F# files without needing to redeclare the type ever again.  I hope C# has a plan for this some day..\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Records\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Yes, this is the same C# Record feature but in different syntax.  While C# uses Kotlin style(which also probably steals from other language too), F#'s record is more verbose.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public record Person(string FirstName, string LastName, int Age);\\n\\n// create a record value\\nvar person = new Person(\\\"John\\\", \\\"Doe\\\", 99);\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In F#:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-fsharp\"\n  }, \"type Person = {\\n    FirstName: string\\n    LastName: string\\n    Age: int\\n}\\n// or\\n// type Person = { FirstName: string; LastName: string; Age: int }\\n\\n// create a record value\\nlet person = { FirstName = \\\"John\\\"; LastName = \\\"Doe\\\"; Age = 99 }\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"If you notice, create a record value in F# doesn't need to even specify the record name! F# recognizes the record type by the assignment names.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Just like C#'s record, F# automatically generates code for data structural equality (and hash calculation) of all fields in the record, and also generates code for data comparison too!\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Tuple\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I assume that our reader knows tuple pretty well from C#. But some may not know that in .NET we have tuple as reference type (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Tuple\"), \") and tuple as value type (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.ValueTuple\"), \"). In recent C# version, whenever you use the tuple form, it is always \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ValueTuple\"), \".  In contrast, Tuple in F# is reference type by default.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-fsharp\"\n  }, \"type Sample1 = string * int         // equivalent to Tuple<string,int> in C#\\ntype Sample2 = struct(string * int) // equivalent to (string, int) in C#\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This may be useful in case you want to tune performance.\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"List\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Anonymous Object\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Tagged Union\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Option vs Nullable\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Result\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Pattern Matching\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Workflow (Computation Expressions)\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Sequence\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Query\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Task\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Async\")), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Unit of Measurement\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#type-alias","title":"Type Alias"},{"url":"#records","title":"Records"},{"url":"#tuple","title":"Tuple"},{"url":"#list","title":"List"},{"url":"#anonymous-object","title":"Anonymous Object"},{"url":"#tagged-union","title":"Tagged Union","items":[{"url":"#option-vs-nullable","title":"Option vs Nullable"},{"url":"#result","title":"Result"},{"url":"#pattern-matching","title":"Pattern Matching"}]},{"url":"#workflow-computation-expressions","title":"Workflow (Computation Expressions)","items":[{"url":"#sequence","title":"Sequence"},{"url":"#query","title":"Query"},{"url":"#task","title":"Task"},{"url":"#async","title":"Async"}]},{"url":"#unit-of-measurement","title":"Unit of Measurement"}]},"timeToRead":1,"parent":{"__typename":"File","relativePath":"to-other-languages/f-sharp-for-c-sharp-developers/data-types-in-f-sharp.md"},"frontmatter":{"metaTitle":null,"showMetadata":true,"editable":true,"showPreviousNext":null,"showToc":true}},"gitBranch":{"name":"main"},"gitCommit":{"hash":"4f1134accef463612ee63776f407d76ae8ca575f","date":"2022-01-30 12:02"}},"pageContext":{"id":"94492c9e-bd82-5b07-adb2-5611c2c9a230"}},"staticQueryHashes":["12478684","12478684","1306071104","2353585426","2353585426","2552263575","2552263575","2882937274","2882937274","353167761","353167761","3812332637","3812332637","4285724809"]}